using HRM.Modules.Identity.Domain.Entities;
using HRM.Modules.Identity.Domain.Repositories;
using Microsoft.EntityFrameworkCore;

namespace HRM.Modules.Identity.Infrastructure.Persistence.Repositories;

/// <summary>
/// Repository implementation for Operator aggregate
/// Provides data access methods using EF Core
///
/// Design Patterns:
/// - Repository Pattern: Encapsulates data access logic
/// - Unit of Work: DbContext tracks changes, SaveChangesAsync commits
/// - Query Object: Returns entities, not IQueryable (keeps domain pure)
///
/// Performance Optimizations:
/// - AsNoTracking for existence checks (faster, less memory)
/// - Indexed columns for Username/Email queries (see OperatorConfiguration)
/// - Case-insensitive comparisons via SQL collation
///
/// Transaction Management:
/// - Add/Update/Remove don't commit immediately
/// - UnitOfWork (ModuleDbContext) commits via SaveChangesAsync
/// - Multiple operations in single transaction supported
///
/// Soft Delete:
/// - Global query filter applied (IsDeleted = false)
/// - Deleted operators excluded from all queries automatically
/// - Use IgnoreQueryFilters() to include deleted (not implemented here)
/// </summary>
internal sealed class OperatorRepository : IOperatorRepository
{
    private readonly IdentityDbContext _context;

    public OperatorRepository(IdentityDbContext context)
    {
        _context = context;
    }

    /// <summary>
    /// Get operator by ID
    /// Returns null if not found or soft deleted
    /// </summary>
    public async Task<Operator?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Operators
            .FirstOrDefaultAsync(o => o.Id == id, cancellationToken);
    }

    /// <summary>
    /// Get operator by username (case-insensitive)
    /// Returns null if not found or soft deleted
    ///
    /// Performance:
    /// - Uses unique index IX_Operators_Username
    /// - Case-insensitive comparison via SQL collation
    /// - Query plan: Index Seek (very fast)
    /// </summary>
    public async Task<Operator?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
    {
        return await _context.Operators
            .FirstOrDefaultAsync(
                o => o.Username.ToLower() == username.ToLower(),
                cancellationToken
            );
    }

    /// <summary>
    /// Get operator by email (case-insensitive)
    /// Returns null if not found or soft deleted
    ///
    /// Performance:
    /// - Uses unique index IX_Operators_Email
    /// - Case-insensitive comparison via SQL collation
    /// - Query plan: Index Seek (very fast)
    /// </summary>
    public async Task<Operator?> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _context.Operators
            .FirstOrDefaultAsync(
                o => o.Email.ToLower() == email.ToLower(),
                cancellationToken
            );
    }

    /// <summary>
    /// Check if username exists (case-insensitive)
    /// More efficient than GetByUsernameAsync for existence checks
    ///
    /// Performance:
    /// - Uses AsNoTracking (no change tracking overhead)
    /// - AnyAsync generates EXISTS query (stops at first match)
    /// - Uses unique index IX_Operators_Username
    /// - Typical execution time: 1-5ms
    /// </summary>
    public async Task<bool> ExistsByUsernameAsync(string username, CancellationToken cancellationToken = default)
    {
        return await _context.Operators
            .AsNoTracking()
            .AnyAsync(
                o => o.Username.ToLower() == username.ToLower(),
                cancellationToken
            );
    }

    /// <summary>
    /// Check if email exists (case-insensitive)
    /// More efficient than GetByEmailAsync for existence checks
    ///
    /// Performance:
    /// - Uses AsNoTracking (no change tracking overhead)
    /// - AnyAsync generates EXISTS query (stops at first match)
    /// - Uses unique index IX_Operators_Email
    /// - Typical execution time: 1-5ms
    /// </summary>
    public async Task<bool> ExistsByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _context.Operators
            .AsNoTracking()
            .AnyAsync(
                o => o.Email.ToLower() == email.ToLower(),
                cancellationToken
            );
    }

    /// <summary>
    /// Add new operator to repository
    /// Does NOT commit to database (use SaveChangesAsync)
    ///
    /// EF Core behavior:
    /// - Tracks entity in Added state
    /// - INSERT executed on SaveChangesAsync
    /// - ID generated by database (default GUID)
    /// </summary>
    public void Add(Operator @operator)
    {
        _context.Operators.Add(@operator);
    }

    /// <summary>
    /// Update existing operator
    /// Does NOT commit to database (use SaveChangesAsync)
    ///
    /// Note: Usually not needed with EF Core change tracking
    /// Just modify entity properties and SaveChangesAsync detects changes
    ///
    /// EF Core behavior:
    /// - If entity tracked: Automatic change detection
    /// - If entity not tracked: Marks as Modified
    /// - UPDATE executed on SaveChangesAsync
    /// </summary>
    public void Update(Operator @operator)
    {
        _context.Operators.Update(@operator);
    }

    /// <summary>
    /// Remove operator from repository
    /// Does NOT commit to database (use SaveChangesAsync)
    ///
    /// Note: Due to soft delete, this should call @operator.Delete() first
    /// Then SaveChangesAsync will UPDATE IsDeleted = true instead of DELETE
    ///
    /// EF Core behavior:
    /// - Tracks entity in Deleted state
    /// - But soft delete interceptor changes to UPDATE
    /// - Sets IsDeleted = true, DeletedAtUtc = now
    /// </summary>
    public void Remove(Operator @operator)
    {
        _context.Operators.Remove(@operator);
    }
}
